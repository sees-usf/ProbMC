# SMT-Based Bounded Model Checking
SMT-based bounded model checking attempts to find a counterexample for a given property within a specified path length and probability.
> Given a system of path length k, with s representing states, T representing transition relations, I representing the initial state, and P representing the property we aim to find a counterexample for, the logic forumula below can be used to find counterexamples.
>
> I(s0) ∧ T(s0, s1) ∧ T(s1, s2) ∧ · · · ∧ T(sk−1, sk) ∧ ¬(P(s1) ∧ · · · ∧ P(sk))
>
> If there exists a path that meets the above criteria, then a counterexample has been found.

## Setting Up
This project uses Python and Z3Prover. Find more information on Z3Prover here: https://github.com/Z3Prover/z3.

To use the SMT-BMC solver, use the model_template.py to set up your module file. Instructions on how to add your model is inside of that model_template.py file. Once you have your own module file created and set up, move it into the src folder (SMT_BMC/src).

Run the SMT-BMC solver by executing the main.py file in the src folder (SMT_BMC/src/main.py). The program will ask for four inputs, whether your module file is in the examples folder or not, the name of your module file (excluding the .py), a path length, and the probability the counterexamples should reach to be considered a problem for the given path length. It will then return whether or not there exists a counterexample that meets or goes over the provided probability along with each step's reached probabilities and the total probability reached.

## Code Explained
The code relies on three files found in the src folder (SMT_BMC/src): main.py, BMC.py, and the module file the user selects when the program is first ran.

### main.py
Asks the user whether or not their module file is located in SMT_BMC/src/examples, the name of the module file containing their model, the path lengh to test for counterexamples, and the probability the counterexamples must meet or go over to be considered a problem. Returns whether or not there exists enough counterexamples to meet or go over the given probability.

This file imports BMC.py to build a BMC object through the user's input, which in turn runs the BMC class's initialization code. The BMC's initialization code prints out all of the most recent steps it has searched through along with each step's probability of finding a counterexample written on the same line. Once the program determines whether or not a counter example can be found, it will print out the answer as well as the total probability the program reached. Essentially, the BMC's initialization code runs the SMT-BMC solver and returns the solution. See BMC.py for more information.

### BMC.py
Encodes the BMC class.

**The BMC constructor (\_\_init\_\_())** first initializes the path length of the model, the name of the module file, the probability the counterexamples must meet, a list of the counterexamples that have been reached, and a Z3Prover solver variable. The path length, module file name, and probability to be met are filled in by the user back in main.py's code. The list of reached counterexamples is used in both BMC's ExcludePath() function and BMC's Check() function to ensure that counterexamples found once are not counted again. The Z3Prover solver variable is used to hold all the constraints that define the bounded model and is also used to determine whether or not the constraints can lead to a total value of True.

Once all the data members of the class are created, the constructor adds the initial states of the model (pulled from the module file's GetInitialStates() method) to the BMC's solver. Since the initial states do not depend on the number of steps taken, they can be added on early in the process, before entering any loops. After this, a loop is ran, moving through steps until the BMC's path length is reached or a counterexample that meets the given probability is reached. As it moves, BMC's PathEncoding() is called to add the next step's path to the last path used, and BMC's Check() method returns the total probability of all the counterexamples within the given step. The code then adds up all the probabilities from each step and prints out whether or not a counterexample fitting the requirements of the user is found along with the total probability reached.

**PathEncoding()** calls the module file's GetStep() method with the step number decremented by 1 to allow the states to start from 0 rather than 1. The GetStep() method returns the constraints used to represent the transition relations during the given step. PathEncoding() adds these constraints into the solver. At this point, the solver should contain the constraints for the initial states of the model, as well as all the transition relations up to the given step. *(Recall that PathEncoding() is called inside of a loop in the BMC constructor)*

**ExcludePath()** returns all counterexamples that have already been found for the model to avoid recounting. This function takes in the counterexample model provided by BMC's Check() method. Due to the way Z3Prover represents models, ExcludePath() has to reconstruct the model back into constraint form using individual pieces of the model. It does this by looping through all the variables at all their steps within the model and setting the name of the variable (declaration.name()) equal to the value of the variable (cx_model[declaration]). It then uses Z3Prover's And() and Not() to stitch all the variables together and create the counterexample to avoid in the future. This counterexample is then added to BMC's reached_cx_list data member for use in BMC's Check() method.

**Check()** finds all the counterexample models at the most recent step it is called on, adds up the probabilities of these counterexamples, and returns the total probability of finding a counterexample at that step. First, the last two parts of the solver are added here, the prior counterexamples from the reached_cx_list that is modified in the ExcludePath() function, and the property to be met in order to find a counterexample. Since the property constraints added to the solver need to be deleted and replaced for every new step, prior to adding the property to the solver, the solver is saved while it contains the initial states, path, and past counterexamples. The property is then added. Once the solver has all the constraints required, a loop is entered that iterates until no further counterexamples can be found. A loop within this loop is used to dig through Z3Prover's representation of a solution model to get the probability of the transitions used at each step. After this,  the newly found counterexample is added to the solver and is also added to the reached_cx_list through the ExcludePath() method. The total probability is calculated and is returned after the solver pops all the additions made to the solver after it had been saved. This means the property is removed as well as the counterexamples added within Check()'s loop, but the initial states, path, and past counterexamples are still within the solver. The new property is added again when Check() is called and, since the past counterexamples were placed in the reached_cx_list data member, they are also added back in at the start of Check().

### Module File
See model_template.py in SMT_BMC for more details and an in-depth description on how you can create your own!

The module file contains three methods: GetStep(), GetProperty(), and GetInitialStates(). GetStep() takes in the step the program is on and returns the transition relations for that step in constraint form using Z3Prover methods. GetProperty() is similar, but instead it returns the property for the given step. Since GetInitialStates() is only for the initial step, it does not need to take in the current step the program is at. Instead, GetInitialStates() hardcodes the initial states into a constraint and returns the constraint. See BMC.py to see how each of these function's returned values are utilized.